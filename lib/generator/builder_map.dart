import 'dart:async';
import 'dart:io';

import 'package:async/async.dart';
import 'package:build/build.dart';
import 'package:build_runner_core/build_runner_core.dart';
import 'package:dart_style/dart_style.dart';
import 'package:frouter/entity/entity.dart';
import 'package:frouter/generator/generator_router_path.dart';
import 'package:frouter/generator/generator_router_map.dart';
import 'package:frouter/generator/util/template_util.dart';
import 'package:logging/logging.dart';
import 'package:path/path.dart' as path;

final _log = Logger('Entrypoint');

class RouterMapPostProcessBuilder extends PostProcessBuilder {
  static Map<String, List<BuildScriptItemContentEntity>> _routerMap = {};

  @override
  FutureOr<void> build(PostProcessBuildStep buildStep) async {
    print(buildStep.inputId);

    // await Future.forEach<String>(
    //     RouterPathGenerator.currentRegisterModuleMap.keys, (moduleKey) async {
    //   await _checkExportFile(
    //       RouterPathGenerator.currentRegisterModuleMap[moduleKey]!.first,
    //       RouterPathGenerator.currentRegisterModuleMap[moduleKey]!);
    // });

    checkRouterHost();
    checkCreateRouterMap(buildStep);
    return;
  }

  @override
  // TODO: implement inputExtensions
  Iterable<String> get inputExtensions => [".yaml"];

  Future<void> _checkExportFile(BuildScriptItemContentEntity contentEntity,
      List<BuildScriptItemContentEntity> contentList) async {
    final targetAsset = AssetId(contentEntity.buildStep.inputId.package,
        'lib/${contentEntity.buildStep.inputId.package}_route_export.dart');
    var package = RouterPathGenerator.packageGraph![targetAsset.package];
    final targetFile = File(path.join(package!.path, targetAsset.path));

    if (!targetFile.existsSync() &&
        RouterPathGenerator.packageGraph?.root.name !=
            contentEntity.buildStep.inputId.package) {
      await _createExportFile(targetAsset, contentEntity, contentList);
    }
  }

  Future<void> _createExportFile(
      AssetId targetAssetId,
      BuildScriptItemContentEntity contentEntity,
      List<BuildScriptItemContentEntity> contentList) async {
    FileBasedAssetWriter writer =
        FileBasedAssetWriter(RouterPathGenerator.packageGraph!);

    await writer.writeAsString(
        targetAssetId, await _createExportContent(contentEntity, contentList));
  }

  Future<String> _createExportContent(
      BuildScriptItemContentEntity contentEntity,
      List<BuildScriptItemContentEntity> contentList) async {
    StringBuffer sb = StringBuffer();

    sb.writeln(
        'library ${contentEntity.buildStep.inputId.package}_route_export;');

    for (BuildScriptItemContentEntity item in contentList) {
      sb.writeln(
          "export '${path.relative(item.buildStep.inputId.path, from: 'lib')}';");
    }

    return DartFormatter().format(sb.toString());
  }

  void checkRouterHost() {
    if (_routerMap.isEmpty) {
      final packageGraph = RouterPathGenerator.packageGraph;
      final registerHostModuleList = RouterGenerator.registerHostList;

      final subRegisterModuleList = registerHostModuleList.where((element) {
        return element.buildStep.inputId.package != packageGraph!.root.name;
      }).toList();

      for (BuildScriptItemContentEntity subModule in subRegisterModuleList) {
        _routerMap[subModule.buildStep.inputId.package] = List.from(
            RouterPathGenerator.currentRegisterModuleMap[
                subModule.buildStep.inputId.package]!);
        RouterPathGenerator.currentRegisterModuleMap
            .remove(subModule.buildStep.inputId.package);
      }

      final leftRouterList =
          RouterPathGenerator.currentRegisterModuleMap.keys.expand((element) {
        return RouterPathGenerator.currentRegisterModuleMap[element]!;
      });
      _routerMap[packageGraph!.root.name] = List.from(leftRouterList);
    }
  }

  void checkCreateRouterMap(PostProcessBuildStep buildStep) {
    if (_routerMap.keys.contains(buildStep.inputId.package)) {
      final targetAsset = AssetId(buildStep.inputId.package,
          'lib/${buildStep.inputId.package}_route.dart');
      var package = RouterPathGenerator.packageGraph![targetAsset.package];
      final targetFile = File(path.join(package!.path, targetAsset.path));

      if (targetFile.existsSync()) {
        targetFile.deleteSync();
      }

      _createRouterMapFile(
          targetAsset, buildStep, _routerMap[buildStep.inputId.package]!);
    }
  }

  void _createRouterMapFile(AssetId targetAsset, PostProcessBuildStep buildStep,
      List<BuildScriptItemContentEntity> list) {
    FileBasedAssetWriter writer =
        FileBasedAssetWriter(RouterPathGenerator.packageGraph!);

    final content = StringBuffer();
    content
      ..writeln('// Generated by lwlizhe frouter plugin, do not edit manually.')
      ..writeln(
          '// run pub run build_runner build --delete-conflicting-outputs')
      ..writeln('// ignore_for_file: directives_ordering')
      ..writeln(GeneratorTemplateUtil.getTemplate(
          packageGraph: RouterPathGenerator.packageGraph!,
          buildStep: buildStep,
          sourceMap: _routerMap));

    writer.writeAsString(
        targetAsset, DartFormatter().format(content.toString()));
  }
}
